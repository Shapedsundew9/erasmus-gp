"""Script to analyze Python profiling data and generate a comprehensive report.

This script reads a .prof file generated by cProfile and outputs a formatted
analysis to a text file. The output includes cumulative time spent in functions,
with directory names stripped for cleaner output.

Usage:
    python profile_analyze.py [--profile PROFILE_FILE] [--output OUTPUT_FILE]

Examples:
    python profile_analyze.py
    python profile_analyze.py --profile my_profile.prof
    python profile_analyze.py --profile profile.prof --output analysis.txt
"""

from argparse import ArgumentParser, Namespace
from pathlib import Path
from pstats import Stats
from sys import exit as sys_exit


def analyze_profile(profile_path: Path, output_path: Path) -> None:
    """Analyze profile data and write the report to the output file.

    Args:
        profile_path: Path to the input profile file.
        output_path: Path to the output text file.

    Raises:
        Exception: If there's an error reading the profile or writing the output.
    """
    try:
        with output_path.open("w", encoding="utf-8") as f:
            # Create a Stats object, streaming output to our file
            stats = Stats(str(profile_path), stream=f)

            # 1. Strip directory names for cleaner output
            stats.strip_dirs()

            # 2. Sort by cumulative time: total time spent in function AND sub-functions
            #    Other options: 'tottime' (time in function only), 'ncalls' (call count)
            stats.sort_stats("cumulative")

            # 3. Print comprehensive statistics (all functions)
            stats.print_stats()

        print(f"Comprehensive profile analysis saved to: {output_path}")
    except Exception as e:
        raise RuntimeError(f"Error analyzing profile: {e}") from e


def main() -> None:
    """Main entry point for the profile analysis script."""
    args = parse_arguments()

    profile_path = Path(args.profile).resolve()
    output_path = Path(args.output).resolve()

    try:
        # Validate inputs
        validate_input_file(profile_path)
        validate_output_file(output_path)

        # Perform analysis
        analyze_profile(profile_path, output_path)

    except (
        FileNotFoundError,
        PermissionError,
        ValueError,
        IsADirectoryError,
        NotADirectoryError,
    ) as e:
        print(f"Error: {e}", file=__import__("sys").stderr)
        sys_exit(1)
    except RuntimeError as e:
        print(f"Error: {e}", file=__import__("sys").stderr)
        sys_exit(1)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.", file=__import__("sys").stderr)
        sys_exit(130)
    except (OSError, IOError) as e:  # pylint: disable=broad-exception-caught
        print(f"Unexpected I/O error: {e}", file=__import__("sys").stderr)
        sys_exit(1)


def parse_arguments() -> Namespace:
    """Parse command line arguments.

    Returns:
        Namespace: Parsed arguments containing profile_file and output_file paths.
    """
    parser = ArgumentParser(
        description="Analyze Python profiling data and generate a comprehensive report.",
        epilog="Common sort keys: 'cumulative' (default), 'tottime', 'ncalls'",
    )
    parser.add_argument(
        "--profile",
        type=str,
        default="profile.prof",
        help="Path to the input profile file (default: profile.prof)",
        metavar="FILE",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="profile_analysis.txt",
        help="Path to the output text file (default: profile_analysis.txt)",
        metavar="FILE",
    )
    return parser.parse_args()


def validate_input_file(profile_path: Path) -> None:
    """Validate that the input profile file exists and is readable.

    Args:
        profile_path: Path object pointing to the profile file.

    Raises:
        FileNotFoundError: If the profile file doesn't exist.
        PermissionError: If the profile file isn't readable.
    """
    if not profile_path.exists():
        raise FileNotFoundError(f"Profile file not found: {profile_path}")
    if not profile_path.is_file():
        raise ValueError(f"Profile path is not a file: {profile_path}")
    if not profile_path.stat().st_size > 0:
        raise ValueError(f"Profile file is empty: {profile_path}")


def validate_output_file(output_path: Path) -> None:
    """Validate that the output file path is writable.

    Args:
        output_path: Path object pointing to the output file.

    Raises:
        PermissionError: If the output directory isn't writable.
        IsADirectoryError: If the output path is a directory.
    """
    if output_path.exists() and output_path.is_dir():
        raise IsADirectoryError(f"Output path is a directory: {output_path}")

    # Check if the parent directory exists and is writable
    parent_dir = output_path.parent
    if not parent_dir.exists():
        raise FileNotFoundError(f"Output directory does not exist: {parent_dir}")
    if not parent_dir.is_dir():
        raise NotADirectoryError(f"Output parent path is not a directory: {parent_dir}")


if __name__ == "__main__":
    main()
